
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Sky</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>

			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
				text
			}

			#info {
				color:#ccc;
				text-shadow: 1px 1px rgba(0,0,0,0.25);
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;

			}

			a {
				color: #fff;
			}

		</style>
	</head>
	<body>


		<script src="js/three.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script src="js/stats.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/please.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/SkyShader.js"></script>
		<script src="js/dat.gui.min.js"></script>


		<script>


			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container;
			var camera, controls, scene, renderer;
			var sky, sunSphere;

			// Variabler
			const N = 200; // Time step
       		var Ypos = calculate();  //Call func calc and it returns ypos
       		var max_of_glitter = 1000;
       		var glitter = [];
       		var time = 0;
       		var diff = calc_step();

			init();
			render();

			function initSky() {

				// Add Sky Mesh
				sky = new THREE.Sky();
				scene.add( sky.mesh);

				// Add Sun Helper
				sunSphere = new THREE.Mesh(
							new THREE.SphereBufferGeometry( 20000, 16, 8 ),
							new THREE.MeshBasicMaterial( { color: 0xffffff } )
				);

				sunSphere.position.y = - 700000;
				sunSphere.visible = false;
				scene.add( sunSphere );

				var distance = 400000;

					var uniforms = sky.uniforms;
					uniforms.turbidity.value = 10;
					uniforms.reileigh.value = 2;
					uniforms.luminance.value = 1;
					uniforms.mieCoefficient.value = 0.005;
					uniforms.mieDirectionalG.value = 0.8;

					var theta = Math.PI * ( 0.49 - 0.5 );
					var phi = 2 * Math.PI * ( 0.25 - 0.5 );


					sunSphere.position.x = distance * Math.cos( phi );
					sunSphere.position.y = distance * Math.sin( phi ) * Math.sin( theta );
					sunSphere.position.z = distance * Math.sin( phi ) * Math.cos( theta );

					sunSphere.visible = ! true;

					sky.uniforms.sunPosition.value.copy( sunSphere.position );

					var geo = new THREE.BoxGeometry( 5, 0.5, 5 );
 				    for (var i = 0; i < max_of_glitter; i++) {
 				    var color = Please.make_color({	// slumpar grå färger
							greyscale: true, //for the brits
							grayscale: true  //for the yanks
							});
 				    var box = {};
 				    var mat = new THREE.MeshPhongMaterial({color});
 				    box.obj = new THREE.Mesh( geo, mat);
 				    
 				    box.x = Math.floor((Math.random() * 300) - 150);
					box.y = 100;
					box.z = Math.floor((Math.random() * 300) - 150);

					box.dx = Math.random();  
			        box.dy = ((Math.random() * 5) + 2)*0.1;
			        box.dz = Math.random();

 				    box.obj.position.set( box.x, box.y, box.z);
			        scene.add(box.obj);

			        box.obj.castShadow = true;
			        box.obj.recieveShadow = true;
			        glitter.push(box);
 				    };

 			var light = new THREE.SpotLight(0xFFFFFF, 5); //Vitt ljus och intensitet (jättestarkt!).
	      	light.position.set( 50, 100, 50 );
	      	scene.add(light);
	      	light.castShadow = true;
	      	light.shadowDarkness = 0.7;

				renderer.render( scene, camera );

			}

			function init() {

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 100, 2000000 );
				camera.position.set( 0, 0, 200 );

				scene = new THREE.Scene();

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render );
				//controls.maxPolarAngle = Math.PI / 2;
				controls.enableZoom = false;
				controls.enablePan = false;

				initSky();

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function calculate () {

			const V0 = 0; // initial speed
			const m = 0.003; // mass in kg
			const g = 9.81; // gravity acceleration kg/m3
			const rho = 1.2; // Air density
			const Amax = 0.06237; // Object maxarea
			const Amin = 0.0100; // Object minarea
			const cw = 0.4; // Numerical drag coefficient
			const deltat= 0.002;
			const N = 200;

			var V = new Array(N); // Speed
			var posY = new Array(N); //Height
			V[0]=V0; //Start velocity
			posY[0] = 10; // Start height

			var t = new Array(N); //Tide 
			
			for(i = 0; i < N; i++)
			{
				t[i] = i * deltat;
			}

			var Arand = (Math.random() * Amax + Amin); // Random nr mellan max och min

			if( Arand < Amax && Arand > Amax/2) //Horrisontellt
				{
					Arand = Amin;
					fallingHor = true;
				}   
			else   //Vertikalt
				{
					Arand = Amax;
				 	fallingHor = false;
				}

			Arand = Amax; // FULKOD

			var k = 0.5*cw*rho*Arand; //Coefficient		 
			   
			for(i=0; i < N; i++)
			{
				V[i+1] = V[i] + deltat * (g-(k/m)*Math.pow(V[i], 2));
				posY[i+1] = posY[i] + V[i]*t[i+1];
			}
			return posY;
		}

		function calc_step () {
				var diff = [];
				for(i=0; i < N; i++)
				{
					if(i < 100)
					{
						diff[i] = Ypos[i] - Ypos[i+1];
					}
					else
					{
						diff[i] = diff[20];
					}
				}
				return diff;
			}

				function update_scene (t) {
				dt = t-time;
				time = t;
				update_pos(dt);
				renderer.render(scene, camera); // render the scene
				window.requestAnimationFrame(update_scene, renderer.domElement);
			}

			update_scene(new Date().getTime());

			var count = 0;
			var add = 1;

			function update_pos () {
			for (var i = 0; i < max_of_glitter; i++) {

				glitter[i].y = glitter[i].y - glitter[i].dy;
				check_floor(glitter[i]);
				
				//console.log(glitter[i].dy);
				glitter[i].obj.position.set( glitter[i].x , glitter[i].y , glitter[i].z);
				}; 
			}

			function check_floor (box) {
				 if(box.y <= -50)
				 {
				 	box.y = -50
				 }
			}


			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				render();

			}

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>

</html>
